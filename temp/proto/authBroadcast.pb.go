// Code generated by protoc-gen-gogo.
// source: authBroadcast.proto
// DO NOT EDIT!

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		authBroadcast.proto

	It has these top-level messages:
		PubRequest
		FwdRequest
		ErrorMsg
*/
package proto

import proto1 "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import bytes "bytes"

import (
	"encoding/binary"
	"hash/fnv"
	"log"
	"net"
	"sort"
	"sync"
	"time"
)

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PubRequest struct {
	PublisherID   int64  `protobuf:"varint,1,opt,name=PublisherID,proto3" json:"PublisherID,omitempty"`
	PublicationID int64  `protobuf:"varint,2,opt,name=PublicationID,proto3" json:"PublicationID,omitempty"`
	Publication   []byte `protobuf:"bytes,3,opt,name=Publication,proto3" json:"Publication,omitempty"`
}

func (m *PubRequest) Reset()         { *m = PubRequest{} }
func (m *PubRequest) String() string { return proto1.CompactTextString(m) }
func (*PubRequest) ProtoMessage()    {}

type FwdRequest struct {
	PublisherID   int64  `protobuf:"varint,1,opt,name=PublisherID,proto3" json:"PublisherID,omitempty"`
	PublicationID int64  `protobuf:"varint,2,opt,name=PublicationID,proto3" json:"PublicationID,omitempty"`
	BrokerID      int64  `protobuf:"varint,3,opt,name=BrokerID,proto3" json:"BrokerID,omitempty"`
	Publication   []byte `protobuf:"bytes,4,opt,name=Publication,proto3" json:"Publication,omitempty"`
}

func (m *FwdRequest) Reset()         { *m = FwdRequest{} }
func (m *FwdRequest) String() string { return proto1.CompactTextString(m) }
func (*FwdRequest) ProtoMessage()    {}

type ErrorMsg struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *ErrorMsg) Reset()         { *m = ErrorMsg{} }
func (m *ErrorMsg) String() string { return proto1.CompactTextString(m) }
func (*ErrorMsg) ProtoMessage()    {}

func init() {
	proto1.RegisterType((*PubRequest)(nil), "proto.PubRequest")
	proto1.RegisterType((*FwdRequest)(nil), "proto.FwdRequest")
	proto1.RegisterType((*ErrorMsg)(nil), "proto.ErrorMsg")
}
func (this *PubRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PubRequest)
	if !ok {
		that2, ok := that.(PubRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PubRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PubRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PubRequest but is not nil && this == nil")
	}
	if this.PublisherID != that1.PublisherID {
		return fmt.Errorf("PublisherID this(%v) Not Equal that(%v)", this.PublisherID, that1.PublisherID)
	}
	if this.PublicationID != that1.PublicationID {
		return fmt.Errorf("PublicationID this(%v) Not Equal that(%v)", this.PublicationID, that1.PublicationID)
	}
	if !bytes.Equal(this.Publication, that1.Publication) {
		return fmt.Errorf("Publication this(%v) Not Equal that(%v)", this.Publication, that1.Publication)
	}
	return nil
}
func (this *PubRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PubRequest)
	if !ok {
		that2, ok := that.(PubRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.PublisherID != that1.PublisherID {
		return false
	}
	if this.PublicationID != that1.PublicationID {
		return false
	}
	if !bytes.Equal(this.Publication, that1.Publication) {
		return false
	}
	return true
}
func (this *FwdRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FwdRequest)
	if !ok {
		that2, ok := that.(FwdRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FwdRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FwdRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FwdRequest but is not nil && this == nil")
	}
	if this.PublisherID != that1.PublisherID {
		return fmt.Errorf("PublisherID this(%v) Not Equal that(%v)", this.PublisherID, that1.PublisherID)
	}
	if this.PublicationID != that1.PublicationID {
		return fmt.Errorf("PublicationID this(%v) Not Equal that(%v)", this.PublicationID, that1.PublicationID)
	}
	if this.BrokerID != that1.BrokerID {
		return fmt.Errorf("BrokerID this(%v) Not Equal that(%v)", this.BrokerID, that1.BrokerID)
	}
	if !bytes.Equal(this.Publication, that1.Publication) {
		return fmt.Errorf("Publication this(%v) Not Equal that(%v)", this.Publication, that1.Publication)
	}
	return nil
}
func (this *FwdRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FwdRequest)
	if !ok {
		that2, ok := that.(FwdRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.PublisherID != that1.PublisherID {
		return false
	}
	if this.PublicationID != that1.PublicationID {
		return false
	}
	if this.BrokerID != that1.BrokerID {
		return false
	}
	if !bytes.Equal(this.Publication, that1.Publication) {
		return false
	}
	return true
}
func (this *ErrorMsg) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ErrorMsg)
	if !ok {
		that2, ok := that.(ErrorMsg)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ErrorMsg")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ErrorMsg but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ErrorMsg but is not nil && this == nil")
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	return nil
}
func (this *ErrorMsg) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ErrorMsg)
	if !ok {
		that2, ok := that.(ErrorMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}

/* Manager type struct */

// Manager manages a pool of machine configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	sync.RWMutex
	machines       []*Machine
	configs        []*Configuration
	machineGidToID map[uint32]int
	configGidToID  map[uint32]int

	closeOnce sync.Once
	logger    *log.Logger
	opts      managerOptions

	publishClients []PublisherAC_PublishClient
	forwardClients []BrokerAC_ForwardClient
}

/* Manager quorum functions */

func (m *Manager) setDefaultQuorumFuncs() {
}

/* Manager create/close streams */

func (m *Manager) createStreamClients() error {
	if m.opts.noConnect {
		return nil
	}

	for _, machine := range m.machines {
		if machine.self {
			continue
		}
		client := NewPublisherACClient(machine.conn)
		publishClient, err := client.Publish(context.Background())
		if err != nil {
			return err
		}
		m.publishClients = append(m.publishClients, publishClient)
	}
	for _, machine := range m.machines {
		if machine.self {
			continue
		}
		client := NewBrokerACClient(machine.conn)
		forwardClient, err := client.Forward(context.Background())
		if err != nil {
			return err
		}
		m.forwardClients = append(m.forwardClients, forwardClient)
	}

	return nil
}

func (m *Manager) closeStreamClients() {
	if m.opts.noConnect {
		return
	}

	for i, client := range m.publishClients {
		_, err := client.CloseAndRecv()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("machine %d: error closing publish client: %v", i, err)
		}
	}
	for i, client := range m.forwardClients {
		_, err := client.CloseAndRecv()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("machine %d: error closing forward client: %v", i, err)
		}
	}
}

/* Manager options */

type managerOptions struct {
	grpcDialOpts []grpc.DialOption
	logger       *log.Logger
	noConnect    bool
	selfAddr     string
	selfGid      uint32
}

/* Gorums Client API */

/* Configuration RPC specific */

// Publishinvokes an asynchronous Publish RPC on configuration c.
// The call has no return value and is invoked on every machine in the
// configuration.
func (c *Configuration) Publish(args *PubRequest) error {
	return c.mgr.publish(c.id, args)
}

// Forwardinvokes an asynchronous Forward RPC on configuration c.
// The call has no return value and is invoked on every machine in the
// configuration.
func (c *Configuration) Forward(args *FwdRequest) error {
	return c.mgr.forward(c.id, args)
}

/* Manager RPC specific */
func (m *Manager) publish(cid int, args *PubRequest) error {
	c, found := m.Configuration(cid)
	if !found {
		panic("execeptional: config not found")
	}

	for _, mid := range c.machines {
		go func(machineID int) {
			stream := m.publishClients[machineID]
			if stream == nil {
				panic("execeptional: machine client stream not found")
			}
			err := stream.Send(args)
			if err == nil {
				return
			}
			if m.logger != nil {
				m.logger.Printf("machine %d: publish stream send error: %v", machineID, err)
			}
		}(mid)
	}

	return nil
}
func (m *Manager) forward(cid int, args *FwdRequest) error {
	c, found := m.Configuration(cid)
	if !found {
		panic("execeptional: config not found")
	}

	for _, mid := range c.machines {
		go func(machineID int) {
			stream := m.forwardClients[machineID]
			if stream == nil {
				panic("execeptional: machine client stream not found")
			}
			err := stream.Send(args)
			if err == nil {
				return
			}
			if m.logger != nil {
				m.logger.Printf("machine %d: forward stream send error: %v", machineID, err)
			}
		}(mid)
	}

	return nil
}

/* Static resources */

/* config.go */

// A Configuration represents a static set of machines on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id       int
	gid      uint32
	machines []int
	mgr      *Manager
	quorum   int
	timeout  time.Duration
	defCtx   context.Context
}

// ID reports the local identifier for the configuration.
func (c *Configuration) ID() int {
	return c.id
}

// GlobalID reports the unique global identifier for the configuration.
func (c *Configuration) GlobalID() uint32 {
	return c.gid
}

// Machines returns a slice containing the local ids of all the machines in the
// configuration.
func (c *Configuration) Machines() []int { return c.machines }

// Quorum returns the quourm size for the configuration.
func (c *Configuration) Quorum() int {
	return c.quorum
}

// Size returns the number of machines in the configuration.
func (c *Configuration) Size() int {
	return len(c.machines)
}

func (c *Configuration) String() string {
	return fmt.Sprintf("configuration %d | gid: %d", c.id, c.gid)
}

// Equal retuns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.gid == b.gid }

// NewTestConfiguration returns a new configuration with quorum size q and
// machine size n. No other fields are set. Configurations returned from this
// constructor should only be used when testing quorum functions.
func NewTestConfiguration(q, n int) *Configuration {
	return &Configuration{
		quorum:   q,
		machines: make([]int, n),
	}
}

/* errors.go */

// A MachineNotFoundError reports that a specified machine could not be found.
type MachineNotFoundError uint32

func (e MachineNotFoundError) Error() string {
	return fmt.Sprintf("machine not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IncompleteRPCError reports that a quorum RPC call failed.
type IncompleteRPCError struct {
	ErrCount, ReplyCount int
}

func (e IncompleteRPCError) Error() string {
	return fmt.Sprintf(
		"incomplete rpc (errors: %d, replies: %d)",
		e.ErrCount, e.ReplyCount,
	)
}

// An TimeoutRPCError reports that a quorum RPC call timed out.
type TimeoutRPCError struct {
	Waited                 time.Duration
	ErrCount, RepliesCount int
}

func (e TimeoutRPCError) Error() string {
	return fmt.Sprintf(
		"rpc timed out: waited %v (errors: %d, replies: %d)",
		e.Waited, e.ErrCount, e.RepliesCount,
	)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

// ManagerCreationError returns an error reporting that a Manager could not be
// created due to err.
func ManagerCreationError(err error) error {
	return fmt.Errorf("could not create manager: %s", err.Error())
}

/* machine.go */

// Machine encapsulates the state of a machine on which a remote procedure call
// can be made.
type Machine struct {
	// Only assigned at creation.
	id   int
	gid  uint32
	self bool
	addr string
	conn *grpc.ClientConn

	sync.Mutex
	lastErr error
	latency time.Duration
}

func (m *Machine) connect(opts ...grpc.DialOption) error {
	conn, err := grpc.Dial(m.addr, opts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}
	m.conn = conn
	return nil
}

// ID returns the local ID of m.
func (m *Machine) ID() int {
	return m.id
}

// GlobalID returns the global id of m.
func (m *Machine) GlobalID() uint32 {
	return m.gid
}

// Address returns network address of m.
func (m *Machine) Address() string {
	return m.addr
}

// ConnState returns the state of the underlying gRPC client connection.
func (m *Machine) ConnState() (grpc.ConnectivityState, error) {
	return m.conn.State()
}

func (m *Machine) String() string {
	m.Lock()
	defer m.Unlock()
	var connState string
	if m.conn == nil {
		connState = "nil"
	} else {
		cstate, err := m.conn.State()
		if err != nil {
			connState = err.Error()
		} else {
			connState = cstate.String()
		}
	}
	return fmt.Sprintf(
		"machine %d | gid: %d | addr: %s | latency: %v | connstate: %v",
		m.id,
		m.gid,
		m.addr,
		m.latency,
		connState,
	)
}

func (m *Machine) setLastErr(err error) {
	m.Lock()
	defer m.Unlock()
	m.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this machine.
func (m *Machine) LastErr() error {
	m.Lock()
	defer m.Unlock()
	return m.lastErr
}

func (m *Machine) setLatency(lat time.Duration) {
	m.Lock()
	defer m.Unlock()
	m.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this machine.
func (m *Machine) Latency() time.Duration {
	m.Lock()
	defer m.Unlock()
	return m.latency
}

type lessFunc func(m1, m2 *Machine) bool

// MultiSorter implements the Sort interface, sorting the machines within.
type MultiSorter struct {
	machines []*Machine
	less     []lessFunc
}

// Sort sorts the argument slice according to the less functions passed to
// OrderedBy.
func (ms *MultiSorter) Sort(machines []*Machine) {
	ms.machines = machines
	sort.Sort(ms)
}

// OrderedBy returns a Sorter that sorts using the less functions, in order.
// Call its Sort method to sort the data.
func OrderedBy(less ...lessFunc) *MultiSorter {
	return &MultiSorter{
		less: less,
	}
}

// Len is part of sort.Interface.
func (ms *MultiSorter) Len() int {
	return len(ms.machines)
}

// Swap is part of sort.Interface.
func (ms *MultiSorter) Swap(i, j int) {
	ms.machines[i], ms.machines[j] = ms.machines[j], ms.machines[i]
}

// Less is part of sort.Interface. It is implemented by looping along the
// less functions until it finds a comparison that is either Less or
// !Less. Note that it can call the less functions twice per call. We
// could change the functions to return -1, 0, 1 and reduce the
// number of calls for greater efficiency: an exercise for the reader.
func (ms *MultiSorter) Less(i, j int) bool {
	p, q := ms.machines[i], ms.machines[j]
	// Try all but the last comparison.
	var k int
	for k = 0; k < len(ms.less)-1; k++ {
		less := ms.less[k]
		switch {
		case less(p, q):
			// p < q, so we have a decision.
			return true
		case less(q, p):
			// p > q, so we have a decision.
			return false
		}
		// p == q; try the next comparison.
	}
	// All comparisons to here said "equal", so just return whatever
	// the final comparison reports.
	return ms.less[k](p, q)
}

// ID sorts machines by their local identifier in increasing order.
var ID = func(m1, m2 *Machine) bool {
	return m1.id < m2.id
}

// GlobalID sorts machines by their global identifier in increasing order.
var GlobalID = func(m1, m2 *Machine) bool {
	return m1.gid < m2.gid
}

// Latency sorts machines by latency in increasing order. Latencies less then
// zero (sentinel value) are considered greater than any positive latency.
var Latency = func(m1, m2 *Machine) bool {
	if m1.latency < 0 {
		return false
	}
	return m1.latency < m2.latency

}

// Error sorts machines by their LastErr() status in increasing order. A
// machine with LastErr() != nil is larger than a machine with LastErr() == nil.
var Error = func(m1, m2 *Machine) bool {
	if m1.lastErr != nil && m2.lastErr == nil {
		return false
	}
	return true
}

// Connectivity sorts machines by "best"/highest connectivity in increasing
// order. The (gRPC) connectivity status is ranked as follows:
// * Ready
// * Connecting
// * Idle
// * TransientFailure
// * Shutdown
var Connectivity = func(m1, m2 *Machine) bool {
	m1State, m1Err := m1.conn.State()
	m2State, m2Err := m2.conn.State()
	switch {
	case m1Err != nil && m2Err == nil:
		return false
	case m1Err != nil && m2Err != nil:
		return true
	case m1Err == nil && m2Err != nil:
		return true
	case m1State <= grpc.Ready && m2State <= grpc.Ready:
		// Both are idle/connecting/ready.
		return m1State < m2State
	case m1State > grpc.Ready && m2State > grpc.Ready:
		// Both are transient/shutdown.
		return m1State > m2State
	case m1State > grpc.Ready && m2State < grpc.Ready:
		// m1 is transient/shutdown and m2 is idle/connecting/ready.
		return true
	default:
		// m2 is transient/shutdown and m1 is idle/connecting/ready.
		return false
	}
}

// Temporary to suppress varcheck warning.
var _ = Connectivity

/* mgr.go */

// NewManager attempts to connect to the given set of machines addresses and if
// successful returns a new Manager containing connections to those machines.
func NewManager(machineAddrs []string, opts ...ManagerOption) (*Manager, error) {
	if len(machineAddrs) == 0 {
		return nil, fmt.Errorf("could not create manager: no machines provided")
	}

	m := new(Manager)
	m.machineGidToID = make(map[uint32]int)
	m.configGidToID = make(map[uint32]int)

	for _, opt := range opts {
		opt(&m.opts)
	}

	selfAddrIndex, selfGid, err := m.parseSelfOptions(machineAddrs)
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	gidSeen := false
	for i, maddr := range machineAddrs {
		machine, err := m.createMachine(maddr)
		if err != nil {
			return nil, ManagerCreationError(err)
		}
		m.machines = append(m.machines, machine)
		if i == selfAddrIndex {
			machine.self = true
			continue
		}
		if machine.gid == selfGid {
			machine.self = true
			gidSeen = true
		}
	}
	if selfGid != 0 && !gidSeen {
		return nil, ManagerCreationError(
			fmt.Errorf("WithSelfGid provided, but no machine with gid %d found", selfGid),
		)
	}

	OrderedBy(GlobalID).Sort(m.machines)

	for i, machine := range m.machines {
		machine.id = i
		m.machineGidToID[machine.gid] = machine.id
	}

	err = m.connectAll()
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	err = m.createStreamClients()
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	m.setDefaultQuorumFuncs()

	return m, nil
}

func (m *Manager) parseSelfOptions(addrs []string) (int, uint32, error) {
	if m.opts.selfAddr != "" && m.opts.selfGid != 0 {
		return 0, 0, fmt.Errorf("both WithSelfAddr and WithSelfGid provided")
	}
	if m.opts.selfGid != 0 {
		return -1, m.opts.selfGid, nil
	}
	if m.opts.selfAddr == "" {
		return -1, 0, nil
	}

	seen, index := contains(m.opts.selfAddr, addrs)
	if !seen {
		return 0, 0, fmt.Errorf(
			"option WithSelfAddr provided, but address %q was not present in address list",
			m.opts.selfAddr)
	}

	return index, 0, nil
}

func (m *Manager) createMachine(addr string) (*Machine, error) {
	m.Lock()
	defer m.Unlock()

	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return nil, fmt.Errorf("create machine %s error: %v", addr, err)
	}

	h := fnv.New32a()
	_, _ = h.Write([]byte(tcpAddr.String()))
	gid := h.Sum32()

	if _, machineExists := m.machineGidToID[gid]; machineExists {
		return nil, fmt.Errorf("create machine %s error: machine already exists", addr)
	}

	ma := &Machine{
		gid:     gid,
		addr:    tcpAddr.String(),
		latency: -1 * time.Second,
	}

	m.machineGidToID[gid] = -1

	return ma, nil
}

func (m *Manager) connectAll() error {
	if m.opts.noConnect {
		return nil
	}
	for _, machine := range m.machines {
		if machine.self {
			continue
		}
		err := machine.connect(m.opts.grpcDialOpts...)
		if err != nil {
			return fmt.Errorf("connect machine %s error: %v", machine.addr, err)
		}
	}
	return nil
}

func (m *Manager) closeMachineConns() {
	for _, machine := range m.machines {
		if machine.self {
			continue
		}
		err := machine.conn.Close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("machine %d: error closing connection: %v", machine.id, err)
		}
	}
}

// Close closes all machine connections and any client streams.
func (m *Manager) Close() {
	m.closeOnce.Do(func() {
		m.closeStreamClients()
		m.closeMachineConns()
	})
}

// MachineIDs returns the identifier of each available machine.
func (m *Manager) MachineIDs() []int {
	m.RLock()
	defer m.RUnlock()
	ids := make([]int, len(m.machines))
	for i := range m.machines {
		ids[i] = i
	}
	return ids
}

// MachineGlobalIDs returns the global identifier of each available machine.
func (m *Manager) MachineGlobalIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	gids := make([]uint32, len(m.machineGidToID))
	for gid, id := range m.machineGidToID {
		gids[id] = gid
	}
	return gids
}

// Machine returns the machine with the given local identifier if present.
func (m *Manager) Machine(id int) (machine *Machine, found bool) {
	m.RLock()
	defer m.RUnlock()
	if id < 0 || id >= len(m.machines) {
		return nil, false
	}
	machine = m.machines[id]
	if machine == nil {
		return nil, false
	}
	return machine, true
}

// MachineFromGlobalID returns the machine with the given global identifier if
// present.
func (m *Manager) MachineFromGlobalID(gid uint32) (machine *Machine, found bool) {
	m.RLock()
	defer m.RUnlock()
	localID, found := m.machineGidToID[gid]
	if !found {
		return nil, false
	}
	return m.Machine(localID)
}

// Machines returns a slice of each available machine.
func (m *Manager) Machines(excludeSelf bool) []*Machine {
	m.RLock()
	defer m.RUnlock()
	var machines []*Machine
	for _, machine := range m.machines {
		if excludeSelf && machine.self {
			continue
		}
		machines = append(machines, machine)
	}
	return machines
}

// ConfigurationIDs returns the identifier of each available configuration.
func (m *Manager) ConfigurationIDs() []int {
	m.RLock()
	defer m.RUnlock()
	ids := make([]int, len(m.configs))
	for i := range m.configs {
		ids[i] = i
	}
	return ids
}

// ConfigurationGlobalIDs returns the global identifier of each available
// configuration.
func (m *Manager) ConfigurationGlobalIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	gids := make([]uint32, len(m.configGidToID))
	for gid, id := range m.configGidToID {
		gids[id] = gid
	}
	return gids
}

// Configuration returns the configuration with the given identifier if
// present.
func (m *Manager) Configuration(id int) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	if id < 0 || id >= len(m.configs) {
		return nil, false
	}
	config = m.configs[id]
	if config == nil {
		return nil, false
	}
	return config, true
}

// ConfigurationFromGlobalID returns the configuration with the given global
// identifier if present.
func (m *Manager) ConfigurationFromGlobalID(gid uint32) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	localID, found := m.configGidToID[gid]
	if !found {
		return nil, false
	}
	return m.Configuration(localID)
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.RLock()
	defer m.RUnlock()
	cos := make([]*Configuration, len(m.configs))
	for i := range m.configs {
		cos[i] = m.configs[i]
	}
	return cos
}

// Size returns the number of machines and configurations in the Manager.
func (m *Manager) Size() (machines, configs int) {
	m.RLock()
	defer m.RUnlock()
	return len(m.machines), len(m.configs)
}

// AddMachine attempts to dial to the provide machine address. The machine is
// added to the Manager's pool of machines if a connection was established.
func (m *Manager) AddMachine(addr string) error {
	panic("not implemented")
}

// NewConfiguration returns a new configuration given a set of machine ids and
// a quorum size. Any given gRPC call options will be used for every RPC
// invocation on the configuration.
func (m *Manager) NewConfiguration(ids []int, quorumSize int, timeout time.Duration) (*Configuration, error) {
	m.Lock()
	defer m.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one machine")
	}
	if quorumSize > len(ids) || quorumSize < 1 {
		return nil, IllegalConfigError("invalid quourm size")
	}
	if timeout <= 0 {
		return nil, IllegalConfigError("timeout must be positive")
	}

	var cmachines []*Machine
	for _, mid := range ids {
		if mid < 0 || mid >= len(m.machines) {
			return nil, MachineNotFoundError(mid)
		}
		machine := m.machines[mid]
		if machine == nil {
			return nil, MachineNotFoundError(mid)
		}
		if machine.self && m.selfSpecified() {
			return nil, IllegalConfigError(
				fmt.Sprintf("self (%d) can't be part of a configuration when a self-option is provided", mid),
			)
		}
		cmachines = append(cmachines, machine)
	}

	// Machine ids are sorted by global id to
	// ensure a globally consistent configuration id.
	OrderedBy(GlobalID).Sort(cmachines)

	h := fnv.New32a()
	binary.Write(h, binary.LittleEndian, quorumSize)
	binary.Write(h, binary.LittleEndian, timeout)
	for _, machine := range cmachines {
		binary.Write(h, binary.LittleEndian, machine.gid)
	}
	gcid := h.Sum32()

	cid, found := m.configGidToID[gcid]
	if found {
		if m.configs[cid] == nil {
			panic(fmt.Sprintf("config with gcid %d and cid %d was nil", gcid, cid))
		}
		return m.configs[cid], nil
	}
	cid = len(m.configs)

	c := &Configuration{
		id:       cid,
		gid:      gcid,
		machines: ids,
		mgr:      m,
		quorum:   quorumSize,
		timeout:  timeout,
		defCtx:   context.Background(),
	}
	m.configs = append(m.configs, c)

	return c, nil
}

func (m *Manager) selfSpecified() bool {
	return m.opts.selfAddr != "" || m.opts.selfGid != 0
}

/* opts.go */

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each machine in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its machines. Mainly used for testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// WithSelfAddr returns a ManagerOption which instructs the Manager not to connect
// to the machine with network address addr. The address must be present in the
// list of machine addresses provided to the Manager.
func WithSelfAddr(addr string) ManagerOption {
	return func(o *managerOptions) {
		o.selfAddr = addr
	}
}

// WithSelfGid returns a ManagerOption which instructs the Manager not to
// connect to the machine with global id gid.  The machine with the given
// global id must be present in the list of machine addresses provided to the
// Manager.
func WithSelfGid(gid uint32) ManagerOption {
	return func(o *managerOptions) {
		o.selfGid = gid
	}
}

/* util.go */

func contains(addr string, addrs []string) (found bool, index int) {
	for i, a := range addrs {
		if addr == a {
			return true, i
		}
	}
	return false, -1
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for PublisherAC service

type PublisherACClient interface {
	Publish(ctx context.Context, opts ...grpc.CallOption) (PublisherAC_PublishClient, error)
}

type publisherACClient struct {
	cc *grpc.ClientConn
}

func NewPublisherACClient(cc *grpc.ClientConn) PublisherACClient {
	return &publisherACClient{cc}
}

func (c *publisherACClient) Publish(ctx context.Context, opts ...grpc.CallOption) (PublisherAC_PublishClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PublisherAC_serviceDesc.Streams[0], c.cc, "/proto.PublisherAC/Publish", opts...)
	if err != nil {
		return nil, err
	}
	x := &publisherACPublishClient{stream}
	return x, nil
}

type PublisherAC_PublishClient interface {
	Send(*PubRequest) error
	CloseAndRecv() (*ErrorMsg, error)
	grpc.ClientStream
}

type publisherACPublishClient struct {
	grpc.ClientStream
}

func (x *publisherACPublishClient) Send(m *PubRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *publisherACPublishClient) CloseAndRecv() (*ErrorMsg, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ErrorMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for PublisherAC service

type PublisherACServer interface {
	Publish(PublisherAC_PublishServer) error
}

func RegisterPublisherACServer(s *grpc.Server, srv PublisherACServer) {
	s.RegisterService(&_PublisherAC_serviceDesc, srv)
}

func _PublisherAC_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PublisherACServer).Publish(&publisherACPublishServer{stream})
}

type PublisherAC_PublishServer interface {
	SendAndClose(*ErrorMsg) error
	Recv() (*PubRequest, error)
	grpc.ServerStream
}

type publisherACPublishServer struct {
	grpc.ServerStream
}

func (x *publisherACPublishServer) SendAndClose(m *ErrorMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *publisherACPublishServer) Recv() (*PubRequest, error) {
	m := new(PubRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _PublisherAC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.PublisherAC",
	HandlerType: (*PublisherACServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Publish",
			Handler:       _PublisherAC_Publish_Handler,
			ClientStreams: true,
		},
	},
}

// Client API for BrokerAC service

type BrokerACClient interface {
	Forward(ctx context.Context, opts ...grpc.CallOption) (BrokerAC_ForwardClient, error)
}

type brokerACClient struct {
	cc *grpc.ClientConn
}

func NewBrokerACClient(cc *grpc.ClientConn) BrokerACClient {
	return &brokerACClient{cc}
}

func (c *brokerACClient) Forward(ctx context.Context, opts ...grpc.CallOption) (BrokerAC_ForwardClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerAC_serviceDesc.Streams[0], c.cc, "/proto.BrokerAC/Forward", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerACForwardClient{stream}
	return x, nil
}

type BrokerAC_ForwardClient interface {
	Send(*FwdRequest) error
	CloseAndRecv() (*ErrorMsg, error)
	grpc.ClientStream
}

type brokerACForwardClient struct {
	grpc.ClientStream
}

func (x *brokerACForwardClient) Send(m *FwdRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerACForwardClient) CloseAndRecv() (*ErrorMsg, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ErrorMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for BrokerAC service

type BrokerACServer interface {
	Forward(BrokerAC_ForwardServer) error
}

func RegisterBrokerACServer(s *grpc.Server, srv BrokerACServer) {
	s.RegisterService(&_BrokerAC_serviceDesc, srv)
}

func _BrokerAC_Forward_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerACServer).Forward(&brokerACForwardServer{stream})
}

type BrokerAC_ForwardServer interface {
	SendAndClose(*ErrorMsg) error
	Recv() (*FwdRequest, error)
	grpc.ServerStream
}

type brokerACForwardServer struct {
	grpc.ServerStream
}

func (x *brokerACForwardServer) SendAndClose(m *ErrorMsg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerACForwardServer) Recv() (*FwdRequest, error) {
	m := new(FwdRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _BrokerAC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.BrokerAC",
	HandlerType: (*BrokerACServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Forward",
			Handler:       _BrokerAC_Forward_Handler,
			ClientStreams: true,
		},
	},
}

func (m *PubRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PubRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublisherID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAuthBroadcast(data, i, uint64(m.PublisherID))
	}
	if m.PublicationID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAuthBroadcast(data, i, uint64(m.PublicationID))
	}
	if m.Publication != nil {
		if len(m.Publication) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintAuthBroadcast(data, i, uint64(len(m.Publication)))
			i += copy(data[i:], m.Publication)
		}
	}
	return i, nil
}

func (m *FwdRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FwdRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublisherID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAuthBroadcast(data, i, uint64(m.PublisherID))
	}
	if m.PublicationID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAuthBroadcast(data, i, uint64(m.PublicationID))
	}
	if m.BrokerID != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAuthBroadcast(data, i, uint64(m.BrokerID))
	}
	if m.Publication != nil {
		if len(m.Publication) > 0 {
			data[i] = 0x22
			i++
			i = encodeVarintAuthBroadcast(data, i, uint64(len(m.Publication)))
			i += copy(data[i:], m.Publication)
		}
	}
	return i, nil
}

func (m *ErrorMsg) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ErrorMsg) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAuthBroadcast(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func encodeFixed64AuthBroadcast(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32AuthBroadcast(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAuthBroadcast(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *PubRequest) Size() (n int) {
	var l int
	_ = l
	if m.PublisherID != 0 {
		n += 1 + sovAuthBroadcast(uint64(m.PublisherID))
	}
	if m.PublicationID != 0 {
		n += 1 + sovAuthBroadcast(uint64(m.PublicationID))
	}
	if m.Publication != nil {
		l = len(m.Publication)
		if l > 0 {
			n += 1 + l + sovAuthBroadcast(uint64(l))
		}
	}
	return n
}

func (m *FwdRequest) Size() (n int) {
	var l int
	_ = l
	if m.PublisherID != 0 {
		n += 1 + sovAuthBroadcast(uint64(m.PublisherID))
	}
	if m.PublicationID != 0 {
		n += 1 + sovAuthBroadcast(uint64(m.PublicationID))
	}
	if m.BrokerID != 0 {
		n += 1 + sovAuthBroadcast(uint64(m.BrokerID))
	}
	if m.Publication != nil {
		l = len(m.Publication)
		if l > 0 {
			n += 1 + l + sovAuthBroadcast(uint64(l))
		}
	}
	return n
}

func (m *ErrorMsg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAuthBroadcast(uint64(l))
	}
	return n
}

func sovAuthBroadcast(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAuthBroadcast(x uint64) (n int) {
	return sovAuthBroadcast(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PubRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthBroadcast
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PubRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PubRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherID", wireType)
			}
			m.PublisherID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PublisherID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicationID", wireType)
			}
			m.PublicationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PublicationID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publication", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthBroadcast
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publication = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthBroadcast(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthBroadcast
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FwdRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthBroadcast
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FwdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FwdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherID", wireType)
			}
			m.PublisherID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PublisherID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicationID", wireType)
			}
			m.PublicationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PublicationID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerID", wireType)
			}
			m.BrokerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.BrokerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publication", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthBroadcast
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publication = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthBroadcast(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthBroadcast
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorMsg) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthBroadcast
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthBroadcast
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthBroadcast(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthBroadcast
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuthBroadcast(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuthBroadcast
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthBroadcast
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAuthBroadcast
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAuthBroadcast
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAuthBroadcast(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAuthBroadcast = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuthBroadcast   = fmt.Errorf("proto: integer overflow")
)
